#import <Metal/Metal.h>

bool run() {
  id<MTLDevice> device = MTLCreateSystemDefaultDevice();

  NSError *error = nil;
  NSURL *url = [NSURL fileURLWithPath:@"shader.metallib"];
  id<MTLLibrary> library = [device newLibraryWithURL:url error:&error];
  if (library == nil) {
    NSLog(@"Failed to load the library.");
    return false;
  }

  id<MTLFunction> entrypoint = [library newFunctionWithName:@"entrypoint"];
  if (entrypoint == nil) {
    NSLog(@"Failed to find the entrypoint function.");
    return false;
  }

  id<MTLComputePipelineState> pipeline = [device newComputePipelineStateWithFunction:entrypoint error:&error];
  if (pipeline == nil) {
    NSLog(@"Failed to created pipeline state object, error %@.", error);
    return false;
  }

  id<MTLCommandQueue> command_queue = [device newCommandQueue];
  if (command_queue == nil) {
    NSLog(@"Failed to create the command queue.");
    return false;
  }

  // Arbitrary bucket of bytes
  uint8_t data[276] = {
    0xDE, 0xAD, 0xBE, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0,
    0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC,
    0xDD, 0xEE, 0xFF, 0x00, 0x2A, 0x4B, 0x6C, 0x8D, 0xAE, 0xCF, 0xE0, 0xF1,
    0x31, 0x41, 0x59, 0x26, 0x53, 0x58, 0x97, 0x93, 0x23, 0x84, 0x62, 0x64,
    0x33, 0x83, 0x27, 0x95, 0x02, 0x88, 0x41, 0x97, 0x16, 0x93, 0x99, 0x37,
    0x51, 0x05, 0x82, 0x09, 0x74, 0x94, 0x45, 0x92, 0x30, 0x78, 0x16, 0x36,
    0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0, 0x11, 0x22, 0x33, 0x44,
    0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00,
    0x2A, 0x4B, 0x6C, 0x8D, 0xAE, 0xCF, 0xE0, 0xF1, 0x31, 0x41, 0x59, 0x26,
    0x53, 0x58, 0x97, 0x93, 0x23, 0x84, 0x62, 0x64, 0x33, 0x83, 0x27, 0x95,
    0x02, 0x88, 0x41, 0x97, 0x16, 0x93, 0x99, 0x37, 0x51, 0x05, 0x82, 0x09,
    0x74, 0x94, 0x45, 0x92, 0x30, 0x78, 0x16, 0x36, 0x12, 0x34, 0x56, 0x78,
    0x9A, 0xBC, 0xDE, 0xF0, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
    0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00, 0x2A, 0x4B, 0x6C, 0x8D,
    0xAE, 0xCF, 0xE0, 0xF1, 0x31, 0x41, 0x59, 0x26, 0x53, 0x58, 0x97, 0x93,
    0x23, 0x84, 0x62, 0x64, 0x33, 0x83, 0x27, 0x95, 0x02, 0x88, 0x41, 0x97,
    0x16, 0x93, 0x99, 0x37, 0x51, 0x05, 0x82, 0x09, 0x74, 0x94, 0x45, 0x92,
    0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC,
    0xDD, 0xEE, 0xFF, 0x00, 0x2A, 0x4B, 0x6C, 0x8D, 0xAE, 0xCF, 0xE0, 0xF1,
    0x31, 0x41, 0x59, 0x26, 0x53, 0x58, 0x97, 0x93, 0x23, 0x84, 0x62, 0x64,
    0x33, 0x83, 0x27, 0x95, 0x02, 0x88, 0x41, 0x97, 0x16, 0x93, 0x99, 0x37,
    0x51, 0x05, 0x82, 0x09, 0x74, 0x94, 0x45, 0x92, 0x30, 0x78, 0x16, 0x36,
    0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0, 0x11, 0x22, 0x33, 0x44
  };

  id<MTLBuffer> input = [device newBufferWithLength:276 options:MTLResourceStorageModeShared];
  memcpy(input.contents, data, 276);
  id<MTLBuffer> output = [device newBufferWithLength:12288 options:MTLResourceStorageModeShared];

  id<MTLCommandBuffer> commandBuffer = [command_queue commandBuffer];
  if (commandBuffer == nil) {
    NSLog(@"Failed to create the command buffer.");
    return false;
  }

  id<MTLComputeCommandEncoder> computeEncoder = [commandBuffer computeCommandEncoder];
  if (computeEncoder == nil) {
    NSLog(@"Failed to create the command encoder.");
    return false;
  }

  MTLSize gridSize = MTLSizeMake(1, 1, 1);
  // !!!! Large thread group size is necessary to repro
  MTLSize groupSize = MTLSizeMake(1024, 1, 1);
  [computeEncoder setComputePipelineState:pipeline];
  [computeEncoder setBuffer:input offset:0 atIndex:0];
  [computeEncoder setBuffer:output offset:0 atIndex:1];
  [computeEncoder dispatchThreads:gridSize threadsPerThreadgroup:groupSize];
  [computeEncoder endEncoding];

  [commandBuffer commit];
  [commandBuffer waitUntilCompleted];

  uint32_t expectation = 0xC0FFEE;
  uint32_t *result = output.contents;
  printf("output = %#x\n", result[0]);
  return (*result == expectation);
}

int main(int argc, const char *argv[]) {
  @autoreleasepool {
    if (!run()) {
      return 1;
    }
  }
  return 0;
}
